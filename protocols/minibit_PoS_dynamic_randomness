
Minibit PoS, dynamic stake, injected randomness

global: {
  epoch_seed
  epoch_slots
  epoch_ledger_hash_cutoff
}

chain_state: {
  body: {
    ledger_hash
  }
  header: {
    length
    epoch_ledger_hash
    next_epoch_ledger_hash
    epoch_randomness
    next_epoch_randomness maybe
    slot#
    epoch#
    body_hash
    prev_header_hash
  }
  header_hash
  header_signature
  proof
}

chain_transition: {
  new_ledger_hash
  ledger_proof
  signed_randomness maybe
  slot#
}

apply_transition state transition
  = 
    new_body = 
      ledger_hash = new_ledger_hash
    incr_epoch = (transition.slot# = global.epoch_slots-1)
    epoch_ledger_hash = 
      if incr_epoch 
      then state.next_epoch_ledger_hash
      else state.epoch_ledger_hash
    next_epoch_hash = 
      if transition.slot# <= global.epoch_ledger_hash_cutoff
      then ledger_hash
      else state.next_epoch_ledger_hash
    epoch_randomness =
      if incr_epoch
      then Option.value_exn state.next_epoch_randomness
      else state.epoch_randomness
    next_epoch_randomness =
      if incr_epoch
      then
        None
      else if 
           transition.slot# > global.epoch_ledger_hash_cutoff 
        && state.header.next_epoch_randomness = None 
        && transition.signed_randomness != None
        transition.signed_randomness
      else 
        state.header.next_epoch_randomness
    new_header =
      length = state.length + 1
      epoch_ledger_hash
      next_epoch_hash
      slot# = transition.slot# % global.epoch_slots
      epoch# = state.epoch# + incr_epoch
      body_hash = hash(body)
    header_hash = hash(new_state.header)
    header_signature = sign(header_hash, self_private_key)
    proof = 
      SNARK "zk_state_valid" proving that, for new_state:
        - all old values came from a chain_state with valid proof
        - ledger_proof proves a valid sequence of transactions moved the ledger from state.body.ledger_hash to new_ledger_hash
        - length is one greater than the old length
        - "incr_epoch" computed correctly
        - if incr_epoch, epoch_ledger_hash is state.next_epoch_ledger_hash, else state.epoch_ledger_hash
        - if slot# < global.epoch_ledger_hash_cutoff, next_epoch_ledger_hash is new_ledger_hash, else state.next_epoch_ledger_hash
        - epoch_randomness computed correctly (and if incr_epoch, there was a next_epoch_randomness to unpack)
        - next_epoch_randomness computed correctly
        - next_epoch_randomness was signed by all members of the epoch
        - slot# is greater than the old slot#
        - epoch# = state.epoch# + incr_epoch
        - prev_header_hash is state.header_hash
        - body hash is a hash of the new body
        - header_signature is the signature of header_hash with self_private_key
        - self_private_key corresponds to a public_key that matches the public_key computed as winner for slot#, epoch# under global.epoch_seed and state.epoch_ledger_hash
        - header_hash is a hash of the new header
    {
      body: new_body
      header: new_header
      header_hash
      header_signature
      proof
    }

check_state old_state new_state
  = 
    new_length = new_state.header.most_recent_length
    old_length = old_state.header.most_recent_length
    new_state.proof zk_state_valid verifies new_state
      &&
    new_length > old_length
      &&
    is_time_for_slot(new_state.header.slot#, new_state.header.epoch#)
    
on_event event
  = 
    match event with
    | Received_New_Epoch -> broadcast signed randomness commitment
    | Reached slot# global.epoch_ledger_hash_cutoff -> broadcast signed randomness openings
    | Reached slot# opening timelimit -> broadcast signed randomness recoveries
    | Time_for_slot_transition transition -> 
      try
        state := apply_transition state transition
        broadcast State state
    | State new_state ->
      if check_state state new_state
      then state := new_state
