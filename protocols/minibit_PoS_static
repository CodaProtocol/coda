Minibit PoS, static stake

global: {
  epoch_seed
}

chain_state: {
  body: {
    ledger_hash
  }
  header: {
    length
    slot#
    body_hash
    prev_header_hash
  }
  header_hash
  header_signature
  proof
}

chain_transition: {
  new_ledger_hash
  ledger_proof
  slot#
}

apply_transition state transition
  = 
    new_body = 
      ledger_hash = new_ledger_hash
    new_header =
      length = state.length + 1
      slot# = transition.slot#
      body_hash = hash(body)
    header_hash = hash(new_state.header)
    header_signature = sign(header_hash, self_private_key)
    proof = 
      SNARK "zk_state_valid" proving that, for new_state:
        - all old values came from a chain_state with valid proof
        - ledger_proof proves a valid sequence of transactions moved the ledger from state.body.ledger_hash to new_ledger_hash
        - length is one greater than the old length
        - slot# is greater than the old slot#
        - prev_header_hash is state.header_hash
        - body hash is a hash of the new body
        - header_signature is the signature of header_hash with self_private_key
        - self_private_key corresponds to a public_key that matches the public_key computed as winner for slot# under global.epoch_seed
        - header_hash is a hash of the new header
    {
      body: new_body
      header: new_header
      header_hash
      header_signature
      proof
    }

check_state old_state new_state
  = 
    new_length = new_state.header.most_recent_length
    old_length = old_state.header.most_recent_length
    new_state.proof zk_state_valid verifies new_state
      &&
    new_length > old_length
      &&
    is_time_for_slot(new_state.header.slot#)
    
on_event event
  = 
    match event with
    | Time_for_slot_transition transition -> 
      try
        state := apply_transition state transition
        broadcast State state
    | State new_state ->
      if check_state state new_state
      then state := new_state
