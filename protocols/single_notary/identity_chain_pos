
transaction_chain_tail_state = transaction_chain.transaction_chain_state.tail

global: {
  epoch_seed
  epoch_slots
  epoch_ledger_hash_cutoff
}

chain_state: {
  body: {
    identity
    transaction_chain_ledger_hash
    transaction_chain_strength
    transaction_chain_length
  }
  header: {
    length
    epoch_ledger_hash
    next_epoch_ledger_hash
    epoch_randomness
    next_epoch_randomness maybe
    slot#
    epoch#
    body_hash
    prev_header_hash
  }
  header_hash
  header_signature
  proof
}

chain_transition: {
  signed_randomness maybe
  identity
  slot#
  epoch#
  { new_transaction_chain_tail_state, transaction_chain_transition_proof } option
}

apply_transition state transition
  = 
    if transition.new_transaction_chain_tail_state is not None
      new_body = 
        identity = transition.identity
        transaction_chain_ledger_hash = new_transaction_chain_tail_state.body.new_ledger_hash
        transaction_chain_strength = new_transaction_chain_tail_state.header.strength
        transaction_chain_length = new_transaction_chain_tail_state.header.length
    incr_epoch = (transition.epoch# > state.header.epoch#)
    epoch_ledger_hash = 
      if incr_epoch 
      then state.next_epoch_hash
      else state.epoch_ledger_hash
    next_epoch_hash = 
      if transition.slot# <= global.epoch_ledger_hash_cutoff
      then ledger_hash
      else state.next_epoch_hash
    epoch_randomness =
      if incr_epoch
      then Option.value_exn state.next_epoch_randomness
      else state.epoch_randomness
    next_epoch_randomness =
      if incr_epoch
      then
        None
      else if 
           transition.slot# > global.epoch_ledger_hash_cutoff 
        && state.header.next_epoch_randomness = None 
        && transition.signed_randomness != None
        transition.signed_randomness
      else 
        state.header.next_epoch_randomness
    new_header =
      length = state.length + 1
      epoch_ledger_hash
      next_epoch_hash
      slot# = transition.slot# % global.epoch_slots
      epoch# = transition.epoch#
      body_hash = hash(body)
    header_hash = hash(new_state.header)
    header_signature = sign(header_hash, self_private_key)
    proof = 
      SNARK "zk_state_valid" proving that, for new_state:
        - all old values came from a chain_state with valid proof
        - body.identity valid
        - either
          - has transition.new_transaction_chain_tail_state
            - transition.new_transaction_chain_tail_state has valid proof
            - transaction_chain_ledger_hash from transition.new_transaction_chain_tail_state
            - transaction_chain_strength from transition.new_transaction_chain_tail_state
            - transition.transaction_chain_strength greater than state.body.transaction_chain_strength
            - transaction_chain_transition_proof proves the transition from the previous ledger_hash to the new one
          - or
            - body transaction_chain fields unchanged
        - length is one greater than the old length
        - "incr_epoch" computed correctly
        - if incr_epoch, epoch_ledger_hash is state.next_epoch_ledger_hash, else state.epoch_ledger_hash
        - if slot# < global.epoch_ledger_hash_cutoff, next_epoch_ledger_hash is transaction_chain_ledger_hash, else state.next_epoch_ledger_hash
        - epoch_randomness computed correctly (and if incr_epoch, there was a next_epoch_randomness to unpack)
        - next_epoch_randomness computed correctly
        - next_epoch_randomness was signed by all members of the epoch
        - slot# is greater than the old slot#
        - epoch# > state.epoch#
        - prev_header_hash is state.header_hash
        - body hash is a hash of the new body
        - header_signature is the signature of header_hash with self_private_key
        - self_private_key corresponds to a public_key that matches the public_key computed as winner for slot#, epoch# under global.epoch_seed and state.epoch_ledger_hash
        - header_hash is a hash of the new header
    {
      body: new_body
      header: new_header
      header_hash
      header_signature
      proof
    }

check_state old_state new_state
  = 
    new_length = new_state.header.most_recent_length
    old_length = old_state.header.most_recent_length
    new_state.proof zk_state_valid verifies new_state
      &&
    new_length > old_length
      &&
    is_time_for_slot(new_state.header.slot#, new_state.header.epoch#)
      &&
    new_state.body.transaction_chain_length not k older than newest new_transaction_chain_tail_state.header.length
    
on_event event
  = 
    match event with
    | Received_New_Epoch -> broadcast signed randomness commitment
    | Reached slot# global.epoch_ledger_hash_cutoff -> broadcast signed randomness openings
    | Reached slot# opening timelimit -> broadcast signed randomness recoveries
    | Time_for_slot_transition transition -> 
      try
        state := apply_transition state transition
        broadcast State state
    | State new_state ->
      if check_state state new_state
      then state := new_state

