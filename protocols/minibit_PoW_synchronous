Synchronous Minibit PoW

chain_state: {
  body: {
    ledger_hash
  }
  header: {
    prev_timestamp
    timestamp
    length
    most_recent_strength
    most_recent_difficulty
    nonce
    body_hash
  }
  header_hash
  proof
}

chain_transition: {
  transactions
  new_timestamp
  nonce
}

apply_transition state transition
  = 
    old_ledger = get_matching(state.body.ledger_hash)
    new_ledger = apply(old_ledger, transition.transactions)
    new_ledger_hash = root_hash(new_ledger)
    difficulty = 
      compute_next_difficulty(
        state.header.most_recent_difficulty, 
        state.header.timestamp,
        state.header.new_timestamp)
    new_body = 
      ledger_hash = new_ledger_hash
    new_header =
      prev_timestamp = state.timestamp
      timestamp = transition.timestamp
      length = state.length + 1
      most_recent_strength = state.header.most_recent_strength + difficulty
      most_recent_difficulty = difficulty
      nonce = transition.nonce
      body_hash = hash(body)
    header_hash = hash(new_state.header)
    proof = 
      SNARK proving that, for new_state:
        - all old values came from a chain_state with valid proof
        - new_ledger_hash was obtained via a valid sequence of transactions
        - prev_timestamp is the old state.header.timestamp
        - timestamp is a newer timestamp than the prev timestamp
        - length is one greater than the old length
        - a "current difficulty" is computed correctly from (most_recent_difficulty, timestamp, new_timestamp)
        - the most recent strength is computed correctly from the most_recent_strength and the "current difficulty"
        - most_recent_difficulty is current difficulty
        - body hash is a hash of the new body
        - header_hash is a hash of the new header
        - header_hash meets current difficulty
    {
      body: new_body
      header: new_header
      header_hash
      proof
    }


