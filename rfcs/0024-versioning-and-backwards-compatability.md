## Summary
[summary]: #summary

This is a proposal to ensure that we maximise backwards compatability across
all of our communication protocols.

This follows on from [RFC 0015: Module Versioning](0015-module-versioning.md),
aiming to keep the same underlying module structures but better enforcing their
registration.

## Motivation

[motivation]: #motivation

Our current system for versioning is split into type versioning and type
registration, both of which need to happen to enforce backwards compatability.
The registration stage is not enforced and so may be easily missed.

Further, the registration stage requires some extra boilerplate code that could
easily be generated by an OCaml ppx. Using a ppx could also ensure that this
code is always present when it should be.

Finally, there are complexities around functors and types with parameters that
were not addressed in the original proposal.

## Detailed design

[detailed-design]: #detailed-design

### Module structure

The proposed structure closely mirrors that of the original [RFC
0015](0015-module-versioning.md):

```ocaml
module Module_name = struct
  module Stable = struct
    [%%versioned]

    module V2 = struct
      type t = ...
    end

    module Latest = V2

    module V1 = struct
      type t = ...

      let to_latest t = ...
    end
  end

  type t = Stable.Latest.t
end
```

The ppx that triggers on `versioned` should then convert this module structure
to be compatible with (a slightly tweaked version of) our existing registration
system:

```ocaml
module Module_name = struct
  module Stable = struct
    module V2 = Module_version.Registration.Make_latest_version (struct
      type t = ... [@@deriving bin_io, version]
    end)

    module Latest = V2

    module Registrar = Module_version.Registration.Make (struct
      let name = "module_name"

      type latest = Latest.t
    end)

    module Registered_V2 = Registrar.Register (V2)

    module V1 = Module_version.Registration.Make_version (struct
      type t = ... [@@deriving bin_io, version]

      let to_latest t = ...
    end)

    module Registered_V1 = Registrar.Register (V1)

    let () = Registrar.close ()

    let deserialize_binary_opt = Registrar.deserialize_binary_opt
  end

  type t = Stable.Latest.t = ...
end
```

### Using older versions of types

Types should be referred to by their version *only* in contexts where values
are being serialised or where the types are combined to create another
versioned type. The serialisation code should convert all versions to the
latest version and pass only values of the latest version to any other code.

All code that is not dealing with serialisation should talk about the toplevel
type `t` in the module, which should be aliased to `Stable.Latest.t`.

Any code built using a previous version of a type should be upgraded to use the
latest version when the type is upgraded.

This ensures consistency across all code using the same type interface, and
makes sure that all parts of the codebase are interoperable on the latest
version of the protocol.

### Versioned types and functors

#### The problem

Introducing versioned types inside functors removes a lot of the assurances we
would like to make using the versioning system. Consider the following
situation:

```ocaml
module A = struct
  module Stable = struct
    ...

    module Latest = V1
  end

  type t = Stable.Latest.t
end

module Make (X : sig
  type t [@@deriving bin_io, version]
end) = struct
  module B = struct
    module Stable = struct
      ...

      module Latest = V1
    end

    type t = Stable.Latest.t
  end
end

module V1_Make = Make (A.Stable.V1)
```

If the type `A.t` is moved to a new version, and then later the type `B.t` was
moved to another version, then we would introduce

```ocaml
module V2_Make = Make (A.Stable.V2)
```

and have `V1_Make.B.V1.t`, `V1_Make.B.V2.t`, `V2_Make.B.V1.t`, and
`V2_Make.B.V2.t`. This introduces the unused version `V1_Make.B.V2.t` and
isolates the original version `V1_Make.B.V1.t` from the later versions.

Similarly, if `B.t` was upgraded, followed by `A.t`, then the latest version
`V2_Make.B.V2.t` is isolated from all earlier versions, and an unused version
is introduced in `V2_Make.B.V1.t`.

This also introduces a safety problem: it is possible to pass `A.Stable.Latest`
to the functor. If `A.t` were upgraded in this situation, everything appears to
be versioned, but we have unintentionally abandoned the old versions.

#### The workaround

Versioned types should not be used in the bodies of functors. Instead, the
versioned types should be lifted out of the functor, and should accept type
parameters for the versioned types that would have been introduced by the
functor arguments. For example,

```ocaml
module Functor_type = struct
  module Stable = struct
    [%%versioned]

    module V1 = struct
      type 'a t = ...
    end

    module Latest = V1
  end

  type 'a t = 'a Stable.Latest.t
end

module Functor (A : sig
  module Argument_type : sig
    type t
  end
end) =
struct
  include Functor_type

  type functor_type = Argument_type.t Functor_type.t

  (* Code using `functor_type` *)

  ...
end
```

It is then easy to build a versioned type that combines the appropriate
versions, without introducing any redundant types or lack of safety:

```ocaml
module Combined_type = struct
  module Stable = struct
    [%%versioned]

    module V4 = struct
      type t = Argument_type.Stable.V3.t Functor_type.Stable.V3.t
    end

    module Latest = V4

    module V3 = struct
      type t = Argument_type.Stable.V2.t Functor_type.Stable.V2.t

      let to_latest t = ...
    end

    module V2 = struct
      type t = Argument_type.Stable.V1.t Functor_type.Stable.V2.t

      let to_latest t = ...
    end

    module V1 = struct
      type t = Argument_type.Stable.V1.t Functor_type.Stable.V1.t

      let to_latest t = ...
    end
  end

  type t = Latest.t
end

(* `X.functor_type` = `Combined_type.t`, so values created in `X` can be
   serialised using `Combined_type`
*)
module X = Functor (struct module Argument_type = Argument_type end)
```

This is something that should be enforced by the `[%%versioned]` ppx.

### Types with parameters

There are three different problems that we need to overcome for types with
parameters:
1. The number or meaning of the type parameters to the types may change between
   versions.
   * This would make it extremely complicated and fragile to write a
     registration system for the types.
2. The version that we serialise alongside the value is somewhat misleading: it
   may be describing one of several actual versions, depending upon how its
   parameters change from version to version.
3. There is no obvious good place to pass or store default values for the free
   parts of the type, if they are needed.

To avoid these, we should not register types with parameters at their
definition time. To still have the the maximum level of registration, we
should:
* do no registration if `Latest.t` takes parameters
* only register older versions that take no parameters if `Latest.t` doesn't
  take parameters.

Beyond this, types that take parameters should be versioned alongside their
(also versioned) parameters; see for example `Combined_type` above.

#### Potential issues

The registration system is designed to override the methods created by
`deriving bin_io`, replacing them with versions that serialise the version
alongside the data. For types with parameters, the `bin_io` functions take
other functions as arguments, each representing the corresponding `bin_io`
function for one of the type's parameters. Since these can be applied manually
to create a `bin_io` instance for the parameterised type, it is possible to
work around versioning.

To protect against this happening as far as possible, we should attempt not to
use the `bin_io` methods directly, and always prefer to pass a 'packed module'
using Jane Street's `Core_kernel.Binable.S`.

There are also `Core_kernel.Binable.S1`/`S2`/`S3` signatures for types with 1,
2, and 3 parameters respectively. These should be avoided, for the same reasons
as above.

### Static enforcement

`[@@deriving version]` provided by `Ppx_coda` currently enforces that the types
referred to in a versioned type are also versioned, using a `__versioned__`
value. It also uses the module name to introduce a `version` value with the
numeric version number.

In this additional ppx, we should also disallow the use of `deriving bin_io`
directly, to ensure that all types that are stored or transmitted are
versioned.

To ensure that we do not hit any of the pitfalls of versioned types inside
functors, we should add checks to the ppx for these as well.

We should also ensure that `deriving version` cannot be used except in
`[%%versioned]` modules. Inside these modules, we should support it so that we
can use its existing escape hatches for external types that are known to be
stable.

## Drawbacks
[drawbacks]: #drawbacks

This proposal will complicate the ppx infrastructure for Coda and its
interaction with the dune build system. It may make it harder to maintain the
`Ppx_coda` library that provides this functionality.

Parts of this proposal explicitly ban some code practices that would normally
be acceptable and reasonably common. This will increase the learning curve for
contributing to Coda, and it may be difficult to portray the correct changes to
make in the automatic error messages.

## Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

The style of the ppx in this proposal is designed to be straightforward and
automatic. In particular
* only the necessary structural information needs to be written
* this structural information maps clearly onto the resulting code
* it automatically generates all of the internal versioning-specific code
* the invariants that would guarantee version safety are enforced properly at
  compile time.

The main alternative is our existing situation, as outlined in [RFC
0015](0015-module-versioning.md). This experiences the problems outlined in the
design section ([above](#detailed-design)), which this proposal attempts to
better address.

Without this proposal, we may end up in situations where we appear to be
dealing with a type that we store or transmit in a backwards-compatible way,
but upon changing it we find that we were not.

## Prior art
[prior-art]: #prior-art

* [RFC 0015: Module Versioning](0015-module-versioning.md)
* [`versioned.ml`](../src/lib/ppx_coda/versioned.ml) in the `Ppx_coda` library
* The [`Module_version` library](../src/lib/module_version/)

These describe an implementation of versioned types that this extends.
