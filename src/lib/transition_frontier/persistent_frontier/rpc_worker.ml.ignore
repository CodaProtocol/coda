open Core
open Async

module Make (Inputs : Intf.Inputs_with_transition_storage_intf) = struct
  open Inputs

  module Worker = Worker.Make (Inputs)

  module type S = (module type of Worker)

  module Worker_state = struct
    type t = Worker.t

    type init_arg = string [@@deriving bin_io]

    let create directory_name : t Deferred.t =
      let logger = Logger.create () in
      let worker = Worker.create ~logger ~directory_name () in
      Deferred.return worker
  end

  module Functions = struct
    type ('i, 'o) t =
      'i Bin_prot.Type_class.t
      * 'o Bin_prot.Type_class.t
      * (Worker_state.t -> 'i -> 'o Deferred.t)

    let create input output f : ('i, 'o) t = (input, output, f)

    let handle_diff =
      create
        [%bin_type_class: Incremental_hash.t * Diff.Lite.E.t]
        Incremental_hash.bin_t
        (fun worker (incremental_hash, diff) ->
          Deferred.return (Worker.handle_diff worker incremental_hash diff) )
  end

  module Rpc_worker = struct
    module T = struct
      module F = Rpc_parallel.Function

      type 'w functions =
        { handle_diff:
            ( 'w
            , Incremental_hash.t
              * Diff.Lite.E.t
            , Incremental_hash.t )
            F.t }

      module Worker_state = Worker_state

      module Connection_state = struct
        type init_arg = unit [@@deriving bin_io]

        type t = unit
      end

      module Functions
          (C : Rpc_parallel.Creator
               with type worker_state := Worker_state.t
                and type connection_state := Connection_state.t) =
      struct
        let functions =
          let f (i, o, f) =
            C.create_rpc
              ~f:(fun ~worker_state ~conn_state:_ i -> f worker_state i)
              ~bin_input:i ~bin_output:o ()
          in
          let open Functions in
          {handle_diff= f handle_diff}

        let init_worker_state = Worker_state.create

        let init_connection_state ~connection:_ ~worker_state:_ = return
      end
    end

    include Rpc_parallel.Make (T)
  end

  type t = {connection: Rpc_worker.Connection.t; process: Process.t}

  let create ~directory_name =
    let%map connection, process =
      Rpc_worker.spawn_in_foreground_exn
        ~connection_timeout:(Time.Span.of_min 1.) ~on_failure:Error.raise
        ~shutdown_on:Disconnect ~connection_state_init_arg:() directory_name
    in
    File_system.dup_stdout process ;
    File_system.dup_stderr process ;
    {connection; process}

  let handle_diff {connection; _} hash diff =
    Rpc_worker.Connection.run connection ~f:Rpc_worker.functions.handle_diff
      ~arg:(hash, diff)
end
